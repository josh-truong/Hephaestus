import numpy as np
from .utils import Pose
from .localization import Localization

class ControllerModel():
    def __init__(self, writer, reader):
        self.w, self.r = writer, reader
        self.rtol, self.atol = self.r.ik.rtol, self.r.ik.atol
        self.flex_rtol, self.flex_atol = self.rtol, self.atol
        self.localization = Localization(writer, reader)

    def set_wheel_joint_vel(self, vL, vR):
        self.w.robot.parts["wheel_left_joint"].setVelocity(vL)
        self.w.robot.parts["wheel_right_joint"].setVelocity(vR)

    def manual(self, key):
        keyboard = self.r.device.keyboard
        MAX_SPEED = self.r.constants.robot.MAX_SPEED
        vL, vR = 0, 0
        if key == keyboard.LEFT :
            vL, vR = -MAX_SPEED,  MAX_SPEED
        elif key == keyboard.RIGHT:
            vL, vR =  MAX_SPEED, -MAX_SPEED
        elif key == keyboard.UP:
            vL, vR =  MAX_SPEED,  MAX_SPEED
        elif key == keyboard.DOWN:
            vL, vR = -MAX_SPEED, -MAX_SPEED
        return vL, vR

    def autonomous(self, velocity_rate):
        """Uses inverse_kinematics and a set of waypoints generated by path planning algorithm"""
        state = self.w.env.state
        waypoints = self.r.env.waypoints
        if (waypoints is None):
            raise ValueError("waypoints cannot be none in inverse_kinematics!")
        goal = waypoints[state]
        self.w.env.goal = Pose(goal[0],goal[1],goal[2])
        goal = self.w.env.goal

        # Calculate Error
        rho   = self.localization.get_position_error()
        alpha = self.localization.get_bearing_error()
        eta   = self.localization.get_heading_error()

        # Feedback Controller
        # Controller gains
        p1, p2, p3 = self.r.ik.p1, self.r.ik.p2, self.r.ik.p3
        x_dot, theta_dot = 0, 0
        if (abs(alpha) > self.flex_atol):
            self.flex_atol += 0.001
            theta_dot = p2*alpha
        else:
            x_dot = p1*rho
            theta_dot = p2*alpha + p3*eta
        
        # Adjust wheelspeeds
        AXLE_LENGTH = self.r.constants.robot.AXLE_LENGTH
        MAX_SPEED = self.r.constants.robot.MAX_SPEED

        phi_l = x_dot - ((theta_dot * AXLE_LENGTH) / 2) # Left wheel velocity in rad/s
        phi_r = x_dot + ((theta_dot * AXLE_LENGTH) / 2) # Right wheel velocity in rad/s
        
        # Normalize wheelspeed
        turn_rate  = 0.25 if (np.sign(phi_l) != np.sign(phi_r)) else 1
        phi_l_ratio = 1 if (abs(phi_l) > abs(phi_r)) else abs(phi_l/phi_r)
        phi_r_ratio = 1 if (abs(phi_r) > abs(phi_l)) else abs(phi_r/phi_l)
        phi_l = np.sign(phi_l)*MAX_SPEED*velocity_rate*phi_l_ratio*turn_rate
        phi_r = np.sign(phi_r)*MAX_SPEED*velocity_rate*phi_r_ratio*turn_rate

        # Clamp wheel speeds
        def clamp(n, upper=MAX_SPEED, lower=-MAX_SPEED):
            return max(min(upper, n), lower)
        vL, vR = clamp(phi_l), clamp(phi_r)

        # Stopping criteria
        if (rho < self.flex_rtol):
            # Move to next waypoint criteria
            state += 1 if (state != len(waypoints)-1) else 0
            state = np.clip(state, 0, len(waypoints)-1)
            self.w.env.state = state
            vL, vR = 0, 0
            # A method to prevent robot oscillating
            self.flex_rtol = self.rtol
            self.flex_atol = self.atol

        if (self.r.debug):
            pose = self.r.robot.pose
            print(f"Current State: {state} Final State: {len(waypoints)-1}")
            print(f"start: ({pose.x:< 6.2f}, {pose.y:< 6.2f}, {pose.theta:< 6.2f})")
            print(f"goal:  ({goal.x:< 6}, {goal.y:< 6}, {goal.theta:< 6})")
            print(f"rho_tol: {self.flex_rtol:< 6.2f} alpha_tol: {self.flex_atol:< 6.2f} eta_tol: {self.r.ik.etol:< 6.2f}")
            print(f"    rho: {rho:< 6.2f}     alpha: {alpha:< 6.2f}     eta: {eta:< 6.2f}")
            print(f"x_dot: {x_dot:< 6.2f} theta_dot: {theta_dot:< 6.2f}")
            print(F"vL: {vL:< 6.2f} vR: {vR:< 6.2f}")
        return vL, vR

    def obstacle_avoidance(self, dtol=0.86, sampling=50):
        # lidar_readings = self.m.Mapping.get_lidar_readings()
        # n_rays = len(lidar_readings)

        # l_dist, r_dist = lidar_readings[:n_rays//2], lidar_readings[-n_rays//2:]
        # l_dist.sort(), r_dist.sort()
        # l_dist, r_dist = np.mean(l_dist[:sampling]), np.mean(r_dist[:sampling])

        # if (l_dist > dtol and r_dist > dtol and not self.avoidance):
        #     print("Obstacle Detected")
        #     self.avoidance = True
        # MS = self.m.rConst.MAX_SPEED
        
        
        # if (self.m.Device.robot_step() != -1):
            
        #     vL, vR = (MS*0.2, -MS*0.2) if (l_dist < r_dist) else (-MS*0.2, MS*0.2)
        #     self.m.Localization.update_odometry(vL, vR, print_pose=False)
        #     self.m.Device.set_wheel_joint_vel(vL, vR)




        while(self.m.Device.robot_step() != -1):
            lidar_sensor_readings = self.m.Mapping.get_lidar_readings()
            n_rays = len(lidar_sensor_readings)
            
            lDist = lidar_sensor_readings[:n_rays//2]
            rDist = lidar_sensor_readings[-n_rays//2:]

            lDist.sort()
            rDist.sort()

            lDist = np.mean(lDist[:sampling])
            rDist = np.mean(rDist[:sampling])

            if (lDist > dtol and rDist > dtol):
                break

            MAX_SPEED = self.m.rConst.MAX_SPEED
            vL, vR = (MAX_SPEED*0.2, MAX_SPEED*0.1) if (lDist < rDist) else (MAX_SPEED*0.1, MAX_SPEED*0.2)
            self.m.Device.set_wheel_joint_vel(vL, vR)
            self.m.Localization.update_odometry()